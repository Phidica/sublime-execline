%YAML 1.2
# http://www.sublimetext.com/docs/3/syntax.html

---

# http://www.skarnet.org/software/execline/index.html
name: Execline
file_extensions:
  - elb
first_line_match: ^#!.*\bexeclineb\b
scope: source.shell.execline

# Notes:

# - The execlineb launcher appears to expand all quoted strings into unquoted strings, prior to any component of the command-line being executed.
# - Variables can be named with almost any non-whitespace characters, including escaped whitespace.
# - Hence, variable substitution can span both unquoted and quoted strings, continuing as long as it doesn't encounter whitespace.
# - This means that we need to treat variable substitution as very closely linked to string types, in order to track whether a subsitution is still occurring multiple string types later.

# Use [A-Za-z0-9_]+ for these internal variable names
variables:
  # Separator whitespace - Delimits command names, parameters, etc
  # This is a list
  ws_sep: \s

  # Terminate commands
  # This is a single element
  block_end: \}(?:[{{ws_sep}}]|$)

  # Parameter separators - Can break apart parameters
  param_sep: '{{ws_sep}}'

  # Integer number
  int: '[+-]?[0-9]+'

  # Real (floating-point) number
  real: (?:{{int}}\.?[0-9]*|[+-]?[0-9]*\.?[0-9]+)

contexts:
  main:
    # Pick up comments before the command line starts
    - include: comment

    # The command call can't begin with a close brace. We match this so exclusively early because the base command line scope will end immediately if this is seen by its lookahead
    - match: \}
      push:
        - meta_scope: invalid.illegal.function-call.execline
        - match: (?=[{{param_sep}}])
          pop: true

    # Base command line: goes up until a close brace
    - match: (?=\S)
      push:
        - match: (?=\})
          pop: true

        - include: command-line

  separator-whitespace:
    # Fundamental structure used to separate elements of a command line
    - match: '{{ws_sep}}+'
      scope: meta.function-call.execline

  parameter:
    # We define the fundamental units passed to a command as "parameters", where those which start with a hyphen are "options" and those which don't are "arguments"
    # Parameters are implemented as a sequence of non-operator characters separated by unescaped and unscoped whitespace

    # Order important because the parameter-argument rule doesn't exclude things that look like options
    - include: parameter-option
    - include: parameter-argument

  parameter-common:
    # The typical components allowed anywhere in a parameter

    # Parameters are made of strings, either quoted or unquoted
    # This includes variable substitutions, which can span different string types
    - include: string

  parameter-option:
    # For optimum usefulness to the user, only option parameters receive the variable.parameter scope

    # Long option (parameter starting with two hyphens)
    - match: (?=--)
      push:
        - meta_scope: meta.function-call.parameter.option.long.execline
        - match: (?=[{{param_sep}}])
          pop: true

        - match: --
          scope:
            punctuation.definition.option.long.begin.execline
            meta.string.unquoted.execline
          push:
            - meta_scope: variable.parameter.execline
            - match: (?=[{{param_sep}}=])
              pop: true

            # We mimic the parameter-common context but use a tweaked unquoted string pattern which excludes '='

            - include: variable-substitution-unquoted

            - include: string-quoted

            - match: (?=[^"])
              push:
                - meta_scope: meta.string.unquoted.execline
                - match: (?=[{{param_sep}}{"$=])
                  pop: true
                - include: string-unquoted-patterns

        # Consume the '=' and then use standard parameter patterns as well as numerics
        - match: =
          scope:
            variable.parameter.execline
            punctuation.definition.option.long.separator.execline
            meta.string.unquoted.execline
          push:
            - match: (?=[{{param_sep}}])
              pop: true

            - match: '{{real}}(?=$|[{{param_sep}}])'
              scope:
                meta.string.unquoted.execline
                constant.numeric.execline

            - include: parameter-common

    # Short option (parameter starting with one hyphen)
    - match: -(?=[^{{param_sep}}])
      scope:
        punctuation.definition.option.short.execline
        meta.string.unquoted.execline
      push:
        - meta_scope:
            meta.function-call.parameter.option.short.execline
            variable.parameter.execline
        - match: (?=[{{param_sep}}])
          pop: true
        - include: parameter-common

  parameter-argument:
    # Arguments are a type of parameter never treated like options by the command they are passed to
    # This context must be entirely standalone because it is used in scopes where parameters starting with hyphens are explicitly interpreted as arguments rather than as options

    - match: (?=[^{{param_sep}}])
      # Begin if we do not precede whitespace or an operator
      push:
        # End if we precede whitespace or operators
        - match: (?=[{{param_sep}}])
          pop: true

        # Treat a sequence of integers (with possible sign and decimal separator) as a standalone constant. Don't do this in the string-unquoted-patterns context, so that we can ensure it is a string solely of numbers
        - match: '{{real}}(?=$|[{{param_sep}}])'
          scope:
            meta.function-call.parameter.argument.numeric.execline
            meta.string.unquoted.execline
            constant.numeric.execline

        - include: block-string

        # Use standard parameter patterns for whatever doesn't match the above
        - match: (?!\s)
          push:
            - meta_scope: meta.function-call.parameter.argument.execline
            - match: (?=[{{param_sep}}])
              pop: true
            - include: parameter-common

  command-line:
    # The command-line is one long argv which will be exec'd into. It might be in a block, or it might be the whole script

    # Start on a non-whitespace character
    - match: (?=\S)
      push:
        - [
            {match: '(?={{block_end}})', pop: true},
            {include: separator-whitespace},
            {include: comment},
            {include: command-call-chainload},
            {include: command-call-standard},
          ]

  command-call-chainload:
    # The "builtin" execline commands which are capable of chainloading further commands

    - match: foreground(?=[{{param_sep}}])
      scope:
        meta.function-call.name.execline
        keyword.control.block.execline
        meta.string.unquoted.execline
      push:
        - block-command

  command-call-standard:
    # Check if the command is any other legal command, ie, a standard command

    # A complete command comprising a name element and optional parameter/comment elements
    - match: (?=\S)
      set:
        - [
            {match: '(?={{block_end}})', pop: true},

            # Allowed elements (now forcibly using arguments, no more options)
            {include: separator-whitespace},
            {include: comment},
            {include: parameter-argument},
          ]
        - [
            {match: '(?={{block_end}})', pop: true},

            # End of options (parameter of just two hyphens)
            {match: '--(?=[{{param_sep}}])', scope:
              meta.function-call.parameter.option.end.execline
              variable.parameter.execline
              punctuation.definition.option.end.execline
              meta.string.unquoted.execline,
            pop: true},

            # Allowed elements (including options)
            {include: separator-whitespace},
            {include: comment},
            {include: parameter},
          ]
        - [
            # A name element
            {match: '(?=[{{param_sep}}])', pop: true},
            {include: command-call-standard-name},
          ]

  command-call-standard-name:
    # Treat the element as a fraction of a name made of arbitrary strings
    - match: (?!\s)
      push:
        - meta_scope:
            meta.function-call.name.execline
            variable.function.execline
        - match: (?=[{{param_sep}}])
          pop: true

        - include: parameter-common

  block-command:
    # Exactly one block, possibly preceded by whitespace and comments

    - include: separator-whitespace
    - include: comment

    - match: \{(?=[{{param_sep}}])
      scope: punctuation.section.braces.begin.execline
      set:
        - meta_scope:
            meta.function-call.block.execline
            meta.braces.block-command.execline
        - match: \}(?=[{{param_sep}}]|$)
          scope: punctuation.section.braces.end.execline
          pop: true

        # The inside of a block is indistinguishable from the base environment
        - include: main

    # We're requiring a block, so anything else showing up is a problem
    # Just capture one whitespace-delimited word, then stop complaining
    - match: \S+
      scope: invalid.illegal.block.execline
      pop: true

  block-string:
    # A block that will technically be expanded, but is just parameters in a command. This is to ensure brace balancing
    - match: \{(?=[{{param_sep}}])
      scope:
        meta.function-call.parameter.argument.execline
        meta.string.unquoted.execline
      set:
        - meta_scope: meta.braces.block-string.execline
        - match: \}(?=[{{param_sep}}])
          scope:
            meta.function-call.parameter.argument.execline
            meta.string.unquoted.execline
          pop: true

        # All the normal command call behaviour in here
        - include: separator-whitespace
        - include: comment
        - include: parameter

  comment:
    # A full or inline comment
    - match: \#
      scope: punctuation.definition.comment.execline
      push:
        - meta_scope: comment.line.execline
        - match: \n
          pop: true

  string:
    - match: (?=\")
      push: string-quoted

    - include: string-unquoted

  string-quoted:
    - match: \"
      scope:
        string.quoted.execline
        punctuation.definition.string.begin.execline
      set: string-quoted-continue

  string-quoted-patterns:
    # This list mostly follows the execline documentation
    # They're all for making ASCII characters
    - match: |-
        (?x)
        \\[abtnvfr] # Shortcuts
        |
        \\0x[0-9A-Fa-f]{1,2} # Hex
        |
        \\0[0-7]{1,3} # Octal
        |
        \\[1-9][0-9]{0,2} # Decimal
      scope: constant.character.escape.ascii.execline

    # Escaping a literal newline in a quoted string will effectively remove it
    - match: \\\n
      scope: constant.character.escape.newline.execline

    # And in fact, everything else can be escaped too! But it won't do anything...
    - match: \\.
      scope: constant.character.escape.other.execline

  string-quoted-continue:
    - match: \"
      scope: string.quoted.execline punctuation.definition.string.end.execline
      pop: true

    # We *push* the braces type because after the closing brace, we have to return to a normal string behaviour (right here). We *set* the bare type because the end of a parameter, and hence the end of the string itself, can stop it, and in that case it must handle the end of the string itself. This is very different to way unquoted variables are handled
    - match: (?=\$\{)
      push: variable-substitution-begin-quoted-braces
    - match: (?=\$)
      set: variable-substitution-begin-quoted-bare

    # Apply meta_scope and handle escapes
    - match: ''
      push:
        - meta_scope: string.quoted.execline
        - match: (?=["$])
          pop: true
        - include: string-quoted-patterns

  string-unquoted:
    # Unquoted strings encompass characters that are not whitespace or quoted strings

    # Variable substitution can change the string type
    - match: (?=\$)
      push: variable-substitution-begin-unquoted

    # Apply meta_scope and handle escapes
    - match: ''
      push:
        - meta_scope: meta.string.unquoted.execline
        - match: (?=[{{param_sep}}"$])
          pop: true
        - include: string-unquoted-patterns

  string-unquoted-patterns:
    # Escaping a literal newline in an unquoted string will turn it into a word
    - match: \\\n
      scope: constant.character.escape.newline.execline

    # Everything can be "escaped" in unquoted strings, whether it has other meanings or not
    - match: \\.
      scope: constant.character.escape.other.execline

  variable-substitution-begin-quoted-braces:
    # Variable substitution that starts as a quoted string, but may continue to an unquoted string

    - match: (\$)(\{)
      captures:
        1: string.quoted.execline punctuation.definition.variable.sign.execline
        2: string.quoted.execline punctuation.definition.variable.begin.execline
      set:
        - meta_scope: variable.other.braces.execline

        - match: \}
          scope:
            string.quoted.execline
            punctuation.definition.variable.end.execline
          pop: true

        - match: ''
          push: variable-substitution-began-quoted-braces-continue-quoted

  variable-substitution-begin-quoted-bare:
    # Don't use a meta_scope to set variable.other.bare because we never pop back.
    # We never pop back because we aren't embedded in another context, allowing us to set into whatever context the variable ended as, even if it was different to the context it started as
    - match: \$
      scope:
        variable.other.bare.execline
        string.quoted.execline
        punctuation.definition.variable.sign.execline
      set:
        - variable-substitution-began-quoted-bare-continue-quoted

  variable-substitution-begin-unquoted:
    # Variable substitution that starts as an unquoted string, but may contain quoted strings

    - match: (\$)(\{)
      captures:
        1: meta.string.unquoted.execline punctuation.definition.variable.sign.execline
        2: meta.string.unquoted.execline punctuation.definition.variable.begin.execline
      set:
        - meta_scope: variable.other.braces.execline

        - match: \}
          scope:
            meta.string.unquoted.execline
            punctuation.definition.variable.end.execline
          pop: true

        - match: (?!\})
          push: variable-substitution-began-unquoted-braces-continue-unquoted

    - match: \$
      scope:
        meta.string.unquoted.execline
        punctuation.definition.variable.sign.execline
      set:
        - [
            {meta_scope:
              variable.other.bare.execline},
            {match: '', pop: true},
          ]
        - variable-substitution-began-unquoted-bare-continue-unquoted

  variable-substitution-quoted-common:
    # Start a new variable if we encounter one
    - match: (?=\$\{)
      set: variable-substitution-begin-quoted-braces
    - match: (?=\$)
      set: variable-substitution-begin-quoted-bare

    # Put the appropriate meta_scope on all characters, and handle quoted escapes
    - match: ''
      push:
        - meta_scope: string.quoted.execline
        - match: (?=[{}"$])
          pop: true
        - include: string-quoted-patterns

  variable-substitution-unquoted-common:
    # Start a new variable if we encounter one
    - match: (?=\$)
      set: variable-substitution-begin-unquoted

    # Put the appropriate meta_scope on all characters, and handle unquoted escapes
    - match: (?=[^{{param_sep}}])
      push:
        - meta_scope: meta.string.unquoted.execline
        - match: (?=[{{param_sep}}{}"$])
          pop: true
        - include: string-unquoted-patterns

  variable-substitution-began-quoted-braces-continue-quoted:
    # variable.other applied by variable-substitution-begin-quoted-braces

    # Only a closing brace terminates a braces variable substitution
    - match: (?=[}])
      pop: true

    # Switch into an unquoted variable
    - match: \"
      scope:
        string.quoted.execline
        punctuation.definition.string.end.execline
      set: variable-substitution-began-quoted-braces-continue-unquoted

    - include: variable-substitution-quoted-common

  variable-substitution-began-quoted-braces-continue-unquoted:
    # variable.other applied by variable-substitution-begin-quoted-braces

    # Only a closing brace terminates a braces variable substitution
    - match: (?=[}])
      pop: true

    # Switch to quoted variable
    - match: \"
      scope:
        string.quoted.execline
        punctuation.definition.string.begin.execline
      set: variable-substitution-began-quoted-braces-continue-quoted

    - include: variable-substitution-unquoted-common

  variable-substitution-began-quoted-bare-continue-quoted:
    - meta_content_scope: variable.other.bare.execline

    # Any braces terminate a bare variable substitution
    - match: (?=[{}])
      set: string-quoted-continue

    # Switch into an unquoted variable
    - match: \"
      scope:
        string.quoted.execline
        punctuation.definition.string.end.execline
      set: variable-substitution-began-quoted-bare-continue-unquoted

    - include: variable-substitution-quoted-common

  variable-substitution-began-quoted-bare-continue-unquoted:
    - meta_content_scope: variable.other.bare.execline

    # An unquoted space terminates an unquoted bare variable substitution
    - match: (?=[{{param_sep}}])
      pop: true

    # Any braces terminate a bare variable substitution
    - match: (?=[{}])
      pop: true

    # Switch to quoted variable
    - match: \"
      scope:
        string.quoted.execline
        punctuation.definition.string.begin.execline
      set: variable-substitution-began-quoted-bare-continue-quoted

    - include: variable-substitution-unquoted-common

  variable-substitution-began-unquoted-braces-continue-quoted:
    # variable.other applied by variable-substitution-begin-unquoted

    # Only a closing brace terminates a braces variable substitution
    - match: (?=[}])
      pop: true

    # Switch into an unquoted variable
    - match: \"
      scope:
        string.quoted.execline
        punctuation.definition.string.end.execline
      set: variable-substitution-began-unquoted-braces-continue-unquoted

    - include: variable-substitution-quoted-common

  variable-substitution-began-unquoted-braces-continue-unquoted:
    # variable.other applied by variable-substitution-begin-unquoted

    # Only a closing brace terminates a braces variable substitution
    - match: (?=[}])
      pop: true

    # Switch to quoted variable
    - match: \"
      scope:
        string.quoted.execline
        punctuation.definition.string.begin.execline
      set: variable-substitution-began-unquoted-braces-continue-quoted

    - include: variable-substitution-unquoted-common

  variable-substitution-began-unquoted-bare-continue-quoted:
    # variable.other applied by variable-substitution-begin-unquoted

    # Any braces terminate a bare variable substitution
    - match: (?=[{}])
      pop: true

    # Switch into an unquoted variable
    - match: \"
      scope:
        string.quoted.execline
        punctuation.definition.string.end.execline
      set: variable-substitution-began-unquoted-bare-continue-unquoted

    - include: variable-substitution-quoted-common

  variable-substitution-began-unquoted-bare-continue-unquoted:
    # variable.other applied by variable-substitution-begin-unquoted

    # An unquoted space terminates an unquoted bare variable substitution
    - match: (?=[{{param_sep}}])
      pop: true

    # Any braces terminate a bare variable substitution
    - match: (?=[{}])
      pop: true

    # Switch to quoted variable
    - match: \"
      scope:
        string.quoted.execline
        punctuation.definition.string.begin.execline
      set: variable-substitution-began-unquoted-bare-continue-quoted

    - include: variable-substitution-unquoted-common
