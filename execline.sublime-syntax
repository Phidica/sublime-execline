%YAML 1.2
# http://www.sublimetext.com/docs/3/syntax.html

---

# http://www.skarnet.org/software/execline/index.html
name: Execline
file_extensions:
  - elb
first_line_match: ^#!.*\bexeclineb\b
scope: source.shell.execline

# Notes:

# - The execlineb launcher appears to expand all quoted strings into unquoted strings, prior to any component of the program-line being executed.
# - Variables can be named with almost any non-whitespace characters, including escaped whitespace.
# - Hence, variable substitution can span both unquoted and quoted strings, continuing as long as it doesn't encounter whitespace.
# - This means that we need to treat variable substitution as very closely linked to string types, in order to track whether a subsitution is still occurring multiple string types later.

# Limitations:

# - Successive closing braces after a variable substitution will continue to issue clear_scopes and progressively wipe away all the meta_scope's that are active on that argument. Fortunately this all goes away the moment unquoted whitespace is encountered, and shouldn't be something that intentionally happens in execline scripts, so is considered a fair trade-off.

# Use [A-Za-z0-9_]+ for these internal variable names
variables:
  # Separator whitespace - Delimits command names, parameters, etc
  # This is a list
  ws_sep: \s

  # Terminate commands
  # This is a single element
  block_end: \}(?:[{{ws_sep}}]|$)

  block_punc: '[{}](?:[{{ws_sep}}]|$)'

  # Parameter separators - Can break apart parameters
  param_sep: '{{ws_sep}}'

  # Integer number
  int: '[+-]?[0-9]+'

  # Real (floating-point) number
  real: (?:{{int}}\.?[0-9]*|[+-]?[0-9]*\.?[0-9]+)

contexts:
  main:
    # Pick up comments before the command line starts
    - include: comment

    # The command call can't begin with a close brace. We match this so exclusively early because the base command line scope will end immediately if this is seen by its lookahead
    - match: \}
      push:
        - meta_scope: invalid.illegal.function-call.execline
        - match: (?=[{{param_sep}}])
          pop: true

    # Base command line: goes up until a close brace
    - match: (?=\S)
      push:
        - match: (?=\})
          pop: true

        - include: program-line

  separator-whitespace:
    # Fundamental structure used to separate elements of a command line
    - match: '[{{ws_sep}}]+'
      scope: meta.function-call.execline

  parameter:
    # We define the fundamental units passed to a command as "parameters", where those which start with a hyphen are "options" and those which don't are "arguments"
    # Parameters are implemented as a sequence of non-operator characters separated by unescaped and unscoped whitespace

    # Order important because the parameter-argument context doesn't exclude things that look like options
    - include: parameter-option
    - include: parameter-argument

  parameter-common:
    # The typical components allowed anywhere in a parameter

    # Parameters are made of strings, either quoted or unquoted
    # This includes variable substitutions, which can span different string types
    - include: string

  parameter-option:
    # For optimum usefulness to the user, only option parameters receive the variable.parameter scope
    - include: parameter-option-long
    - include: parameter-option-short-group

  parameter-option-long:
    # Long option (parameter starting with two hyphens)
    - match: (?=--)
      push:
        - meta_scope: meta.function-call.parameter.option.long.execline
        - match: (?=[{{param_sep}}])
          pop: true

        - match: --
          scope:
            punctuation.definition.option.long.begin.execline
            meta.string.unquoted.execline
          push:
            - meta_scope: variable.parameter.execline
            - match: (?=[{{param_sep}}=])
              pop: true

            # We would use the parameter-common context, but we need to exclude '=' from unquoted strings

            - include: string-quoted

            - match: (?=\$)
              push: variable-substitution-begin-unquoted
              # Limitation: '=' isn't able to end this context

            - match: ''
              push:
                - meta_scope: meta.string.unquoted.execline
                - match: (?=[{{param_sep}}{"$=])
                  pop: true
                - include: string-unquoted-patterns

        # Consume the '=' and then use standard parameter patterns as well as numerics
        - match: =
          scope:
            variable.parameter.execline
            punctuation.definition.option.long.separator.execline
            meta.string.unquoted.execline
          push:
            - match: (?=[{{param_sep}}])
              pop: true

            - match: '{{real}}(?=$|[{{param_sep}}])'
              scope:
                meta.string.unquoted.execline
                constant.numeric.execline

            - include: parameter-common

  parameter-option-short-group:
    # Short option (parameter starting with one hyphen)
    # In this form, characters after the first are treated as grouped options
    - match: -(?=[^{{param_sep}}])
      scope:
        punctuation.definition.option.short.execline
        meta.string.unquoted.execline
      push:
        - meta_scope:
            meta.function-call.parameter.option.short.execline
            variable.parameter.execline
        - match: (?=[{{param_sep}}])
          pop: true
        - include: parameter-common

  parameter-option-short-single:
    # Short option (parameter starting with one hyphen)
    # In this form, characters after the first are not consumed so that they may be captured elsewhere as the argument
    - match: -(?=[^{{param_sep}}])
      scope:
        punctuation.definition.option.short.execline
        meta.string.unquoted.execline
      push:
        - meta_scope:
            meta.function-call.parameter.option.short.execline
            variable.parameter.execline
        - match: ((\").(\"))|(.)
          captures:
            1: string.quoted.execline
            2: punctuation.definition.string.begin.execline
            3: punctuation.definition.string.end.execline
            4: meta.string.unquoted.execline
          pop: true

  parameter-argument:
    # Arguments are a type of parameter never treated like options by the command they are passed to
    # This context must be entirely standalone because it is used in scopes where parameters starting with hyphens are explicitly interpreted as arguments rather than as options

    - match: (?=[^{{param_sep}}])
      # Begin if we do not precede whitespace or an operator
      push:
        # End if we precede whitespace or operators
        - match: (?=[{{param_sep}}])
          pop: true

        # Treat a sequence of integers (with possible sign and decimal separator) as a standalone constant. Don't do this in the string-unquoted-patterns context, so that we can ensure it is a string solely of numbers
        - match: '{{real}}(?=$|[{{param_sep}}])'
          scope:
            meta.function-call.parameter.argument.numeric.execline
            meta.string.unquoted.execline
            constant.numeric.execline

        # Use standard parameter patterns for whatever doesn't match the above
        - match: (?!\s)
          push:
            - meta_scope: meta.function-call.parameter.argument.execline
            - match: (?=[{{param_sep}}])
              pop: true
            - include: parameter-common

  program-line:
    # A program-line is a long argv which will be exec'd into. It might be in a block, or it might be the whole script

    # Start on a non-whitespace character
    - match: (?=\S)
      push:
        - [
            {match: '(?={{block_end}})', pop: true},
            {include: separator-whitespace},
            {include: comment},
            {include: command-call-builtin},
            {include: command-call-standard},
          ]

  command-call-builtin:
    # The "builtin" execline commands, which may be capable of chainloading further commands

    # Process state control

    - match: foreground(?=[{{param_sep}}])
      scope:
        meta.function-call.name.execline
        keyword.control.state.foreground.execline
        meta.string.unquoted.execline
      push:
        - block-run-prog

    - match: background(?=[{{param_sep}}])
      scope:
        meta.function-call.name.execline
        keyword.control.state.background.execline
        meta.string.unquoted.execline
      push:
        - block-run-prog
        - command-call-common-opt-arg-weak-list-&pop

    # Scripting

    - match: runblock(?=[{{param_sep}}])
      scope:
        meta.function-call.name.execline
        support.function.scripting.runblock.execline
        meta.string.unquoted.execline
      push:
        - [ {include: command-call-common-arg-&pop} ]
        - [
            {match: '(?=-n)', push: command-call-common-opt-arg-&pop},
            {include: command-call-common-opt-list-&pop},
          ]

  command-call-common-aside-&pop:
    # Allow some "asides" (whitespace, comments), then pop
    - include: separator-whitespace
    - include: comment
    - match: (?=.) # Allow multiline traversal
      pop: true

  command-call-common-arg-&pop:
    # Pop after exactly one argument
    - include: parameter-argument
    - match: ''
      pop: true

  command-call-common-opt-arg-&pop:
    # A short option followed by an argument. Pop after one pair
    - match: (?=-[^{{param_sep}}])
      push:
        - [ {include: command-call-common-arg-&pop} ]
        - [ {include: command-call-common-aside-&pop} ]
        - [
            # Exactly one option
            {include: parameter-option-short-single},
            {match: '', pop: true},
          ]

    - match: ''
      pop: true

  command-call-common-opt-list-&pop:
    # A series of short options without arguments. Pop at an argument or after an end-of-options parameter
    - match: --(?=[{{param_sep}}])
      scope:
        meta.function-call.parameter.option.end.execline
        variable.parameter.execline
        punctuation.definition.option.end.execline
        meta.string.unquoted.execline
      set: command-call-common-aside-&pop

    - include: parameter-option-short-group
    - include: command-call-common-aside-&pop

  command-call-common-opt-arg-weak-list-&pop:
    # A series of short options where each might be followed by an argument. Pop at an extra argument or block punctuation
    - match: (?=-[^{{param_sep}}])
      push:
        - [
            # End at block punctuation or after one argument
            {match: '(?={{block_punc}})', pop: true},
            {include: command-call-common-arg-&pop},
          ]
        - [
            # Eat one or more sequential short options
            {include: parameter-option-short-group},
            {include: command-call-common-aside-&pop},
          ]

    - include: command-call-common-aside-&pop

  command-call-standard:
    # Check if the command is any other legal command, ie, a standard command

    # A complete command comprising a name element and optional parameter/comment elements
    - match: (?=\S)
      set:
        - [
            {match: '(?={{block_end}})', pop: true},

            # Allowed elements (now forcibly using arguments, no more options)
            {include: separator-whitespace},
            {include: comment},
            {include: block-plain},
            {include: parameter-argument},
          ]
        - [
            {match: '(?={{block_end}})', pop: true},

            # End of options (parameter of just two hyphens)
            {match: '--(?=[{{param_sep}}])', scope:
              meta.function-call.parameter.option.end.execline
              variable.parameter.execline
              punctuation.definition.option.end.execline
              meta.string.unquoted.execline,
            pop: true},

            # Allowed elements (including options)
            {include: separator-whitespace},
            {include: comment},
            {include: block-plain},
            {include: parameter},
          ]
        - [
            # A name element
            {match: '(?=[{{param_sep}}])', pop: true},
            {include: command-call-standard-name},
          ]

  command-call-standard-name:
    # Treat the element as a fraction of a name made of arbitrary strings
    - match: (?!\s)
      push:
        - meta_scope:
            meta.function-call.name.execline
            variable.function.execline
        - match: (?=[{{param_sep}}])
          pop: true

        - include: parameter-common

  block-run-prog:
    # A block that will somehow be evaluated ("run") and is expected to contain a properly formed program line
    # TODO: This contrasts with a context block-run-params that doesn't contain a program line

    # Possibly preceded by whitespace and comments
    - include: separator-whitespace
    - include: comment

    - match: \{(?=[{{param_sep}}])
      scope: punctuation.section.braces.begin.execline
      set:
        - meta_scope:
            meta.function-call.block.execline
            meta.braces.block.run.program.execline
        - match: \}(?=[{{param_sep}}]|$)
          scope: punctuation.section.braces.end.execline
          pop: true

        # The inside of this block is indistinguishable from the base environment
        - include: main

    # We're requiring a block, so anything else showing up is a problem
    # Just capture one whitespace-delimited word, then stop complaining
    - match: \S+
      scope: invalid.illegal.block.execline
      pop: true

  block-plain:
    # A block that will get expanded by execlineb, but is just plain parameters somewhere in a standard command. Used to ensure brace balancing
    - match: \{(?=[{{param_sep}}])
      scope:
        meta.function-call.parameter.argument.execline
        meta.string.unquoted.execline
      push:
        - meta_scope: meta.braces.block.plain.execline
        - match: \}(?=[{{param_sep}}])
          scope:
            meta.function-call.parameter.argument.execline
            meta.string.unquoted.execline
          pop: true

        # All the normal command call behaviour in here
        - include: separator-whitespace
        - include: comment
        - include: parameter

  comment:
    # A full or inline comment
    - match: \#
      scope: punctuation.definition.comment.execline
      push:
        - meta_scope: comment.line.execline
        - match: \n
          pop: true

  string:
    - match: (?=\")
      push: string-quoted

    - include: string-unquoted

  string-quoted:
    - match: \"
      scope:
        string.quoted.execline
        punctuation.definition.string.begin.execline
      set: string-quoted-continue

  string-quoted-patterns:
    # This list mostly follows the execline documentation
    # They're all for making ASCII characters
    - match: |-
        (?x)
        \\[abtnvfr] # Shortcuts
        |
        \\0x[0-9A-Fa-f]{1,2} # Hex
        |
        \\0[0-7]{1,3} # Octal
        |
        \\[1-9][0-9]{0,2} # Decimal
      scope: constant.character.escape.ascii.execline

    # Escaping a literal newline in a quoted string will effectively remove it
    - match: \\\n
      scope: constant.character.escape.newline.execline

    # And in fact, everything else can be escaped too! But it won't do anything...
    - match: \\.
      scope: constant.character.escape.other.execline

  string-quoted-continue:
    - match: \"
      scope: string.quoted.execline punctuation.definition.string.end.execline
      pop: true

    - match: (?=\$)
      set: variable-substitution-begin-quoted

    # Apply meta_scope and handle escapes
    - match: ''
      push:
        - meta_scope: string.quoted.execline
        - match: (?=["$])
          pop: true
        - include: string-quoted-patterns

  string-unquoted:
    # Unquoted strings encompass characters that are not whitespace or quoted strings

    # Variable substitution can change the string type
    - match: (?=\$)
      push: variable-substitution-begin-unquoted

    # Apply meta_scope and handle escapes
    - match: ''
      push: string-unquoted-continue

  string-unquoted-patterns:
    # Escaping a literal newline in an unquoted string will turn it into a word
    - match: \\\n
      scope: constant.character.escape.newline.execline

    # Everything can be "escaped" in unquoted strings, whether it has other meanings or not
    - match: \\.
      scope: constant.character.escape.other.execline

  string-unquoted-continue:
    - meta_scope: meta.string.unquoted.execline

    - match: (?=[{{param_sep}}"$])
      pop: true

    - include: string-unquoted-patterns

  variable-substitution-begin-quoted:
    # Variable substitution that starts as a quoted string, but may continue to an unquoted string

    - match: (\$)(\{)
      captures:
        0: string.quoted.execline
        1: punctuation.definition.variable.sign.execline
        2: punctuation.definition.variable.begin.execline
      set:
        - [
            {meta_scope: variable.other.braces.execline},
            {match: '', pop: true},
          ]
        - variable-substitution-quoted-continue

    # Can't use variable-substitution-quoted-continue and the meta_scope/clear_scopes approach, because a '}' would get variable.bare
    - match: \$
      scope:
        variable.other.bare.execline
        string.quoted.execline
        punctuation.definition.variable.sign.execline
      set:
        - variable-substitution-quoted-continue-bare

  variable-substitution-begin-unquoted:
    # Variable substitution that starts as an unquoted string, but may contain quoted strings

    - match: (\$)(\{)
      captures:
        0: meta.string.unquoted.execline
        1: punctuation.definition.variable.sign.execline
        2: punctuation.definition.variable.begin.execline
      set:
        - [
            {meta_scope: variable.other.braces.execline},
            {match: '', pop: true},
          ]
        - variable-substitution-unquoted-continue

    # Can't use variable-substitution-unquoted-continue and the meta_scope/clear_scopes approach, because a '}' would get variable.bare
    - match: \$
      scope:
        variable.other.bare.execline
        meta.string.unquoted.execline
        punctuation.definition.variable.sign.execline
      set: variable-substitution-unquoted-continue-bare

  variable-substitution-quoted-common:
    # Start a new variable if we encounter one
    - match: (?=\$)
      set: variable-substitution-begin-quoted

    # Put the appropriate meta_scope on all characters, and handle quoted escapes
    - match: ''
      push:
        - meta_scope: string.quoted.execline
        - match: (?=[{}"$])
          pop: true
        - include: string-quoted-patterns

  variable-substitution-unquoted-common:
    # Unquoted whitespace ends parameter, terminates variable substitution
    - match: (?=[{{param_sep}}])
      pop: true

    # Start a new variable if we encounter one
    - match: (?=\$)
      set: variable-substitution-begin-unquoted

    # Put the appropriate meta_scope on all characters, and handle unquoted escapes
    - match: (?=[^{{param_sep}}])
      push:
        - meta_scope: meta.string.unquoted.execline
        - match: (?=[{{param_sep}}{}"$])
          pop: true
        - include: string-unquoted-patterns

  variable-substitution-quoted-continue:
    # Assume a closing brace is terminating a braces variable substitution
    - match: \}
      scope:
        string.quoted.execline
        punctuation.definition.variable.end.execline
      set:
        - [
            {clear_scopes: 1},
            {match: '', pop: true},
          ]
        - variable-substitution-quoted-continue

    # Switch to unquoted string
    - match: \"
      scope:
        string.quoted.execline
        punctuation.definition.string.end.execline
      set: variable-substitution-unquoted-continue

    - include: variable-substitution-quoted-common

  variable-substitution-unquoted-continue:
    # Assume a closing brace is terminating a braces variable substitution
    - match: \}
      scope:
        meta.string.unquoted.execline
        punctuation.definition.variable.end.execline
      set:
        - [
            {clear_scopes: 1},
            {match: '', pop: true},
          ]
        - variable-substitution-unquoted-continue

    # Switch to quoted string
    - match: \"
      scope:
        string.quoted.execline
        punctuation.definition.string.begin.execline
      set: variable-substitution-quoted-continue

    - include: variable-substitution-unquoted-common

  variable-substitution-quoted-continue-bare:
    - meta_content_scope: variable.other.bare.execline

    # Any braces terminate a bare variable substitution
    - match: (?=[{}])
      set: variable-substitution-quoted-continue

    # Switch to unquoted variable
    - match: \"
      scope:
        string.quoted.execline
        punctuation.definition.string.end.execline
      set: variable-substitution-unquoted-continue-bare

    - include: variable-substitution-quoted-common

  variable-substitution-unquoted-continue-bare:
    - meta_content_scope: variable.other.bare.execline

    # Any braces terminate a bare variable substitution
    - match: (?=[{}])
      set: variable-substitution-unquoted-continue

    # Switch to quoted variable
    - match: \"
      scope:
        string.quoted.execline
        punctuation.definition.string.begin.execline
      set: variable-substitution-quoted-continue-bare

    - include: variable-substitution-unquoted-common
